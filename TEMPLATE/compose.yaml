# ──────────────────────────────────────────────────────────────
#  HomeStack Compose File — compose.yaml
#  All ${VARIABLES} are substituted at runtime from:
#    1. config.env   — image tags, ports, paths  (committed)
#    2. secrets.env  — passwords, API keys        (generated at install)
#    3. homestack.env — global paths (APPDATA_DIR, MEDIA_DIR, etc.)
# ──────────────────────────────────────────────────────────────

services:
  # ── Main application container ───────────────────────────────
  myapp:
    image: ${MYAPP_IMAGE}
    container_name: myapp
    restart: unless-stopped
    ports:
      - "${MYAPP_PORT}:8080"          # host:container
    volumes:
      - ${APPDATA_DIR}/myapp:/data    # persistent config/state
      # - ${MEDIA_DIR}/movies:/movies # uncomment if media access needed
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      # Reference secrets from secrets.env:
      # - DB_PASSWORD=${DB_PASSWORD}
    env_file:
      - secrets.env                    # auto-loaded for secret vars

    # ── Health check (strongly recommended) ────────────────────
    # Lets HomeStack report real status via `homestack status`
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

    # ── Resource limits (optional but recommended) ─────────────
    # deploy:
    #   resources:
    #     limits:
    #       memory: 512M

  # ── Example sidecar (database, cache, etc.) ──────────────────
  # myapp-db:
  #   image: postgres:16
  #   container_name: myapp-db
  #   restart: unless-stopped
  #   volumes:
  #     - ${APPDATA_DIR}/myapp-db:/var/lib/postgresql/data
  #   environment:
  #     - POSTGRES_USER=${DB_USERNAME}
  #     - POSTGRES_PASSWORD=${DB_PASSWORD}
  #     - POSTGRES_DB=myapp
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${DB_USERNAME}"]
  #     interval: 30s
  #     timeout: 5s
  #     retries: 3
